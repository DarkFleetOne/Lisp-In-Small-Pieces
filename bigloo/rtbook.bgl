;;; $Id: rtbook.bgl,v 1.9 1998/05/01 09:38:24 queinnec Exp queinnec $

;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
;;; This file is part of the files that accompany the book:
;;;     LISP Implantation Semantique Programmation (InterEditions, France)
;;; By Christian Queinnec <Christian.Queinnec@INRIA.fr>
;;; Newest version may be retrieved from:
;;;   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
;;; Check the README file before using this file.
;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

;;; This file defines some functions that should be included in programs
;;; compiled with the interpreter of the book.

(module rtbook
        (eval (export-all))
        ;; Time utility
        (foreign (int time (string) "time"))
        ;; Meroonet (preceded by a small hack that also defines the
        ;; define-abbreviation macro)
        (include "bigloo/hack.bgl")
        (include "meroonet/meroonet.scm")
        ;; Additional utilities
        (include "src/tester.scm")
        (include "common/pp.scm")
        (include "common/format.scm")
        ;; Exported from this file
        (export meroonet-error
                tester-error
                (test file)
                the-Point
                display-exception
                wrong
                static-wrong
                (list* . args)
                (get-internal-run-time)
                internal-time-units-per-second
                (atom? x)
                (iota start end)
                putprop
                (start options) )
        ;; From format.scm and pp.scm, do not export pp that already exists in
        ;; Bigloo.
        (export (format destination control-string . args))
        ;; Exported from tester.scm
        (export (interpreter a b c d)
                (suite-test a b c d e f) )
        ;; Exported from Meroonet
        (export (number->class n)
                (->Class name)
                (->Generic name)
                *last-defined-class*
                (object->class o)
                (Object? o)
                (symbol-concatenate . names)
                Object-class
                Class-class
                Generic-class
                Field-class
                Mono-Field-class
                Poly-Field-class
                (make-predicate class)
                (is-a? o class)
                (check-class-membership o class)
                (make-allocator class)
                (make-maker class)
                (retrieve-named-field class name)
                (make-reader field)
                (field-value o field . i)
                (make-writer field)
                (set-field-value! o v field . i)
                (make-lengther field)
                (field-length o field)
                (register-class name super-name own-field-descriptions)
                (Class-initialize! class name super own-field-descriptions)
                (Field-defining-class field)
                Class? 
                Generic?
                Field?
                Mono-Field?
                Poly-Field?
                Class-name
                set-Class-name!
                Class-number
                set-Class-number!
                Class-fields
                set-Class-fields!
                Class-superclass
                set-Class-superclass!
                Class-subclass-numbers
                set-Class-subclass-numbers!
                make-Class 
                allocate-Class
                make-Generic
                allocate-Generic
                Generic-name
                set-Generic-name!
                Generic-default
                set-Generic-default!
                Generic-dispatch-table
                set-Generic-dispatch-table!
                Generic-signature
                set-Generic-signature!
                Field-name
                set-Field-name!
                Field-defining-class-number
                set-Field-defining-class-number!
                make-Mono-Field
                allocate-Mono-Field
                make-Poly-Field
                allocate-Poly-Field
                (register-generic generic-name default signature)
                (register-method generic-name pre-method class-name signature)
                (determine-method generic o) )
        )

;(display "[rtbook.bgl...")(newline) ; DEBUG

;;; Include an eval so exported global variables can also appear as symbols.
(eval ''hack) 

;;; This variable is used in chap8k.scm to determine the underlying Scheme
;;; interpreter.

(define book-interpreter-support 'bigloo)

;;; Measure times.

(define (get-internal-run-time)
  (let ((t (make-string 4)))
    (time t) ) )

(define internal-time-units-per-second 1)

;;; My tests suppose that the atom? function is present

(define (atom? x) (not (pair? x)))

;;; I also like the iota function. (iota 0 4) -> (0 1 2 3)

(define (iota start end)
  (if (< start end)
      (cons start (iota (+ 1 start) end))
      '() ) )

(define (every? p . args)
  (let andmap ((args args) (value #t))
    (if (let any-at-end? ((ls args))
          (and (pair? ls)
               (or (not (pair? (car ls)))
                   (any-at-end? (cdr ls)))))
        value
        (let ((value (apply p (map car args))))
          (and value (andmap (map cdr args) value))))))

(define (any? p . args)
  (let ormap ((args args) (value #f))
    (if (let any-at-end? ((ls args))
          (and (pair? ls)
               (or (not (pair? (car ls)))
                   (any-at-end? (cdr ls)))))
        value
        (let ((value (apply p (map car args))))
          (or value (ormap (map cdr args) value))))))

;;; Sometimes, property lists are used.
(define putprop putprop!)

;;; Give a name to the some ports.
;;; These were the names in Scheme->C that I duplicate for Bigloo.

(define stdout-port (current-output-port))
(define stderr-port (current-error-port))

(define flush-buffer flush-output-port)

;;; Quick and dirty: sometimes very big objects are printed, limit
;;; them to something affordable.

(define *bounded-length* 4)
(define *bounded-depth* 3)

(define (bounded-display o stream)
  (define (print-list o* len dep)
    (cond ((null? o*) #t)
          ((atom? o*) (display " . " stream)
                      (display o* stream) )
          ((pair? o*) 
           (print (car o*) len (+ dep 1))
           (if (pair? (cdr o*)) (display " " stream))
           (print-list (cdr o*) (+ len 1) dep) ) ) )
  (define (print o len dep)
    (cond ((object? o) 
           (display "#<" stream)
           (display (Class-name (object->class o)) stream)
           (display ">" stream) )
          ((atom? o) (display o stream))
           (else (if (or (> len *bounded-length*)
                         (> dep *bounded-depth*) )
                     (display "&&&" stream)
                     (begin
                       (display "(" stream)
                       (print-list o len dep)
                       (display ")" stream) ) ) ) ) )
  (print o 0 0) )
;;; Test: (bounded-display (call-with-input-file "si/reflisp.scm" read) stdout-port)

;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;; Defines specific error handlers for meroonet.scm and tester.scm

(define meroonet-error 'wait)

(define tester-error 'wait)

;(set! tester-call/cc 
;      (lambda (f)
;        (bind-exit (k) (f k)) ) )

;;; This function will test meroonet on its test suite.

(define (test file)
  (suite-test
   file "?? " "== " #t
   (lambda (read check err)
     (set! meroonet-error err)
     (set! tester-error err)
     (lambda ()
       (try (check (eval (read)))
            (lambda (k a b c) (err a b c) ) ) ) )
   equal? ) )

;;; This variable is needed by meroonet/oo-tests.scm test suite.

(define the-Point 'useful4tests)

;;; Needed by src/tester.scm
(define display-exception display)

;;; They also suppose some variables to be predefined such as wrong
;;; when runtime errors are caught or static-wrong for preparation
;;; errors.

(define wrong 'wait)
(define static-wrong 'wait)

;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;; Calls to this function might be generated by syntax-case.scm

(define (list* . args)
  (if (pair? args)
      (if (pair? (cdr args))
          (cons (car args) (apply list* (cdr args)))
          (car args) )
      (quote ()) ) )

;;;ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
;;; A small toplevel loop.

;(define (syntax-case-load file)
;  (call-with-input-file file
;    (lambda (in)
;      (newline)
;      (display ";;; Loading ")
;      (display file)
;      (newline)
;      (let loop ((e (read in)))
;        (if (eof-object? e) 
;            file
;            (let ((r (eval e)))
;              (display ";= ")
;              (display r)
;              (newline)
;              (loop (read in)) ) ) ) ) ) )

(define (start options)
  (display "[C. Queinnec's book] Bigloo+Meroonet...")
  (newline)
  (interpreter
   "? " "= " #t
   (lambda (read print error)
     (set! tester-error   error)
     (set! meroonet-error error)
     (lambda ()
       (try (print (eval (read)))
            (lambda (k a b c) (error a b c)) ) ) ) )
  (display " Ite LiSP est.")
  (newline) )

;(display " ...")(newline) ; DEBUG

;;; The `show' and `clone' generic functions are predefined in Meroon
;;; not in Meroonet.  The problem is to define a generic function with
;;; Meroonet macros while these macros are only compiled and not yet
;;; present.

;;; The clone function that performs a shallow copy of a Meroonet object.

(eval '
       (begin
          ;;(display " . . .")(newline) ; DEBUG
          (define-generic (show (o) . stream)
            (let ((stream (if (pair? stream) (car stream)
                              (current-output-port) )))
              (bounded-display o stream) ) )
          (define-generic (clone (o))
            (list->vector (vector->list o)) ) )
       )

;(display "]")(newline) ; DEBUG

;;; end of rtbook.bgl
