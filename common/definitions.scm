;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
;;; This file is part of the files that accompany the book:
;;;     LISP Implantation Semantique Programmation (InterEditions, France)
;;; By Christian Queinnec <Christian.Queinnec@INRIA.fr>
;;; Newest version may be retrieved from:
;;;   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
;;; Check the README file before using this file.
;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

;;; Missing functions:

(define (atom? x) (not (pair? x)))

(define (iota start end)
  (if (< start end)
      (cons start (iota (+ 1 start) end))
      '() ) )

(define (every? p . args)
  (let andmap ((args args) (value #t))
    (if (let any-at-end? ((ls args))
          (and (pair? ls)
               (or (not (pair? (car ls)))
                   (any-at-end? (cdr ls)))))
        value
        (let ((value (apply p (map car args))))
          (and value (andmap (map cdr args) value))))))

(define (any? p . args)
  (let ormap ((args args) (value #f))
    (if (let any-at-end? ((ls args))
          (and (pair? ls)
               (or (not (pair? (car ls)))
                   (any-at-end? (cdr ls)))))
        value
        (let ((value (apply p (map car args))))
          (or value (ormap (map cdr args) value))))))

;;; Calls to this function might be generated by syntax-case.scm

(define (list* . args)
  (if (pair? args)
      (if (pair? (cdr args))
          (cons (car args) (apply list* (cdr args)))
          (car args) )
      (quote ()) ) )

;;; Name the Un*x ports
(define stdout-port (current-output-port))
(define stderr-port (current-error-port))

;;; Quick and dirty: sometimes very big objects are printed, limit
;;; them to something affordable.
(define *bounded-length* 4)
(define *bounded-depth* 3)

(define (bounded-display o stream)
  (define (print-list o* len dep)
    (cond ((null? o*) #t)
          ((atom? o*) (display " . " stream)
                      (display o* stream) )
          ((pair? o*)
           (print (car o*) len (+ dep 1))
           (if (pair? (cdr o*)) (display " " stream))
           (print-list (cdr o*) (+ len 1) dep) ) ) )
  (define (print o len dep)
    (cond ((Object? o)
           (display "#<" stream)
           (display (Class-name (object->class o)) stream)
           (display ">" stream) )
          ((atom? o) (display o stream))
           (else (if (or (> len *bounded-length*)
                         (> dep *bounded-depth*) )
                     (display "&&&" stream)
                     (begin
                       (display "(" stream)
                       (print-list o len dep)
                       (display ")" stream) ) ) ) ) )
  (print o 0 0) )
;;; Test: (bounded-display (call-with-input-file "si/reflisp.scm" read) stdout-port)

;;; Generally, when an error is detected in one of my programs, a
;;; <something>-error function is called which calls itself wrong. The
;;; wrong function allows the test-driver to be aware that something
;;; went wrong.

(define wrong 'wait)
(define static-wrong 'wait)

;;; Defines specific locations for error handlers for meroonet.scm and
;;; tester.scm. They will be filled later.

(define meroonet-error 'wait)
(define tester-error 'wait)

;;; This variable is needed by meroonet/oo-tests.scm test suite.
(define the-Point 'useful4tests)
