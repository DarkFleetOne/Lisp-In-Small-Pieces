;;; $Id: book.scm,v 1.6 1996/02/11 14:09:30 queinnec Exp $

;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
;;; This file is part of the files that accompany the book:
;;;     LISP Implantation Semantique Programmation (InterEditions, France)
;;; By Christian Queinnec <Christian.Queinnec@INRIA.fr>
;;; Newest version may be retrieved from:
;;;   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
;;; Check the README file before using this file.
;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

;;; Missing functions:

(define gensym
  (let ((counter 99))
    (lambda args
      (set! counter (+ counter 1))
      (string->symbol
       (string-append
        (if (pair? args) (car args) "G")
        (number->string counter) ) ) ) ) )

(define call/cc call-with-current-continuation)
(define (atom? x) (not (pair? x)))

;;; I also like the iota function. (iota 0 4) -> (0 1 2 3)

(define (iota start end)
  (if (< start end)
      (cons start (iota (+ 1 start) end))
      '() ) )

(define (every? p . args)
  (let andmap ((args args) (value #t))
    (if (let any-at-end? ((ls args))
          (and (pair? ls)
               (or (not (pair? (car ls)))
                   (any-at-end? (cdr ls)))))
        value
        (let ((value (apply p (map car args))))
          (and value (andmap (map cdr args) value))))))

(define (any? p . args)
  (let ormap ((args args) (value #f))
    (if (let any-at-end? ((ls args))
          (and (pair? ls)
               (or (not (pair? (car ls)))
                   (any-at-end? (cdr ls)))))
        value
        (let ((value (apply p (map car args))))
          (or value (ormap (map cdr args) value))))))

(define (symbol-append . args)
  (string->symbol
   (apply string-append
          (map (lambda (s)
                 (cond ((string? s) s)
                       ((symbol? s) (symbol->string s))
                       ((number? s) (number->string s))
                       (else (error 'symbol-append args)) ) )
               args ) ) ) )

;;; Name the Un*x ports and flush them.

(define stdout-port (current-output-port))
(define stderr-port (current-error-port))

;;; Quick and dirty: sometimes very big objects are printed, limit
;;; them to something affordable.

(define *bounded-length* 4)
(define *bounded-depth* 3)

(define (bounded-display o stream)
  (define (print-list o* len dep)
    (cond ((null? o*) #t)
          ((atom? o*) (display " . " stream)
                      (display o* stream) )
          ((pair? o*) 
           (print (car o*) len (+ dep 1))
           (if (pair? (cdr o*)) (display " " stream))
           (print-list (cdr o*) (+ len 1) dep) ) ) )
  (define (print o len dep)
    (cond ((object? o) 
           (display "#<" stream)
           (display (Class-name (object->class o)) stream)
           (display ">" stream) )
          ((atom? o) (display o stream))
           (else (if (or (> len *bounded-length*)
                         (> dep *bounded-depth*) )
                     (display "&&&" stream)
                     (begin
                       (display "(" stream)
                       (print-list o len dep)
                       (display ")" stream) ) ) ) ) )
  (print o 0 0) )
;;; Test: (bounded-display (call-with-input-file "si/reflisp.scm" read) stdout-port)

;;; Sometimes property lists are seldom used.
;;; I did not find them quickly so I use a (slow) replacement.

(define putprop 'wait)
(define getprop 'wait)

(let ((properties '()))
  (set! putprop
        (lambda (symbol key value)
          (let ((plist (assq symbol properties)))
            (if (pair? plist)
                (let ((couple (assq key (cdr plist))))
                  (if (pair? couple)
                      (set-cdr! couple value)
                      (set-cdr! plist (cons (cons key value)
                                            (cdr plist) )) ) )
                (let ((plist (list symbol (cons key value))))
                  (set! properties (cons plist properties)) ) ) )
          value ) )
  (set! getprop
        (lambda (symbol key)
          (let ((plist (assq symbol properties)))
            (if (pair? plist)
                (let ((couple (assq key (cdr plist))))
                  (if (pair? couple)
                      (cdr couple)
                      #f ) )
                #f ) ) ) ) )

;;; Calls to this function might be generated by syntax-case.scm

(define (list* . args)
  (if (pair? args)
      (if (pair? (cdr args))
          (cons (car args) (apply list* (cdr args)))
          (car args) )
      (quote ()) ) )

;;; Two macros that I frequently use:
(define-syntax unless
  (syntax-rules ()
    ((unless condition form ...)
     (if (not condition) (begin form ...)) ) ) )

(define-syntax when
  (syntax-rules ()
    ((when condition form ...)
     (if condition (begin form ...)) ) ) )

;;; This function loads a file expanded with syntax-expand.
;;;
;;; 2014 Note: This function is not needed anymore, since the built-in load can
;;; now do syntax-case expansion. Leaving this here for now since the verbose
;;; loading might prove useful for debugging.

(define *syntax-case-load-verbose?* #f)

(define (syntax-case-load file)
  (call-with-input-file file
    (lambda (in)
      (if *syntax-case-load-verbose?* 
          (begin (newline)
                 (display ";;; Loading ")
                 (display file)
                 (newline) ) )
      (let loop ((e (read in)))
        (if (eof-object? e) 
            file
            (let ((r (eval e)))
              (if *syntax-case-load-verbose?*
                  (begin (display ";= ")
                         (display r)
                         (newline) ) )
              (loop (read in)) ) ) ) ) ) )

;;; Defines specific locations for error handlers for meroonet.scm and
;;; tester.scm. They will be filled later.

(define meroonet-error 'wait)

(define tester-error 'wait)
(define support-error 'wait)
(define error-hook error)

;;; pp is already present but not format. but format needs internal functions
;;; of pp so redefine pp.

(load "common/pp.scm")

(load "common/format.scm")

;;; Load the test-driver.

(load "src/tester.scm")

;;; Load Meroonet. Meroonet defines three macros with
;;; define-meroonet-macro.
;;; TODO: is eval needed?
;(define-macro (define-meroonet-macro call . body)
;  `(begin (eval '(define-macro ,call . ,body))
;          (define-macro ,call . ,body) ) )
(define-macro (define-meroonet-macro call . body)
  `(define-macro ,call . ,body) )

;;; This variable is needed by meroonet/oo-tests.scm test suite.
(define the-Point 'useful4tests)

(load "meroonet/meroonet.scm")

;;; Since the define-abbreviation is also necessary for the book when non high
;;; level macros are defined, register define-abbreviation for syntax-case. 

(define-syntax define-abbreviation
  (syntax-rules ()
    ((define-abbreviation call . body)
     (define-meroonet-macro call . body) ) ) )

;;; The test-driver should try to catch errors of the underlying Scheme 
;;; system. This is non-portable and difficult in many implementations. If
;;; you do not succeed writing it, you can still run the programs of the book
;;; but you will not be able to run all the test-suites since some tests 
;;; (for instance in meroonet/oo-tests.scm) require errors to be caught
;;; when signalled by list-tail with a non-numeric second argument.

;;; TODO where are these used?
(define-syntax catch-error
  (syntax-rules ()
    ((catch-error forms ...)
     (protected-eval
      (lambda ()
        (list (begin forms ...)) ) ) ) ) )

(define (make-new-error exit)
  (lambda (string . culprits)
    (newline stderr-port)
    (display "== ERROR == " stderr-port)
    (display string stderr-port)
    (newline stderr-port)
    (for-each (lambda (o) (bounded-display o stderr-port))
              culprits )
    (newline stderr-port)
    (exit '**error**) ) )

(define (protected-eval thunk)
  (call/cc (lambda (exit)
             (with-exception-catcher (make-new-error exit)
		 thunk ) )) )
;;; Test: (protected-eval (lambda () (car #t)))

;;; Generally, when an error is detected in one of my programs, a
;;; <something>-error function is called which calls itself wrong. The
;;; wrong function allows the test-driver to be aware that something
;;; went wrong.

(define wrong 'wait)
(define static-wrong 'wait)

;;; The `show' and `clone' generic functions are predefined in Meroon
;;; not in Meroonet.  The problem is to define a generic function with
;;; Meroonet macros while these macros are only compiled and not yet
;;; present.

;;; The clone function that performs a shallow copy of a Meroonet object.

;;; TODO is eval needed?
(eval '(begin
          (define-generic (show (o) . stream)
            (let ((stream (if (pair? stream) (car stream)
                              (current-output-port) )))
              (bounded-display o stream) ) )
          (define-generic (clone (o))
            (list->vector (vector->list o)) ) ) )

;;; The test-driver should try to catch errors of the underlying Scheme system.
;;; This is non-portable and difficult in many implementations. If do not
;;; succeed writing it, you can still run the programs of the book but you will
;;; not be able to run all the test-suites since some tests (for instance in
;;; meroonet/oo-tests.scm) require errors to be caught when signalled by
;;; list-tail with a non-numeric second argument.

;(set! error-handler
;      (lambda error-msg
;        (error-print error-msg) ) )

;;; This function will test a suite of tests.

(define (test file)
  (suite-test
   file "?? " "== " #t
   make-toplevel
   equal? ) )
;;; Test: 
;;;	(test "meroonet/oo-tests.scm")
;;;	(test "src/syntax.tst")

;;; A small toplevel loop.
(define (start)
  (display "[C. Queinnec's book] ")
  (display book-interpreter-name)
  (display "+Meroonet...")
  (newline)
  (set! *syntax-case-load-verbose?* #t)
  (set! load syntax-case-load)
  (interpreter
   "? " "= " #t
   make-toplevel )
  (display " Ite LiSP est.")
  (newline)
  (exit 0) )

;;; Warp into the new toplevel.
(start)
;;; end of book.scm
