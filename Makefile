###(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
### This file is part of the files that accompany the book:
###     LISP Implantation Semantique Programmation (InterEditions, France)
### By Christian Queinnec <Christian.Queinnec@INRIA.fr>
### Newest version may be retrieved from:
###   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
### Check the README file before using this file.
###(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

# Makefile generated by imake - do not edit!
# $Xorg: imake.c,v 1.6 2001/02/09 02:03:15 xorgcvs Exp $

default.work : build.interpreter

# This is the Imakefile of the distribution.  The first part defines
# the variables that you may have to setup in order to run the
# tests. The second part defines how to test the various parts of
# the sourcef files.

# If you decide to build a specialized interpreter on top of Bigloo
# then indicate the correct command to invoke bigloo.

BIGLOO = bigloo

# If you decide to build a specialized interpreter on top of Gambit
# then indicate the correct command to invoke the Gambit compiler.
#
# 2014 Note: The default binary name is ``gsc'', but that name
# conflicts with the ghostscript binary on my Archlinux system, so
# the gambit compiler has been renamed to gambitc.

GSC = gambitc

# If you decide to build multiple specialized interpreters on
# multiple machines, then you must give different HOSTTYPE for all
# these CPU-different machines. Very often, HOSTTYPE is set up for
# you by your shell (tcsh does this). If so, you can leave empty
# this definition, it will be automatically inherited from your
# shell.

export HOSTTYPE := $(shell uname -m)

# Choose a Scheme interpreter. This interpreter must contain
# Meroonet, hygienic macros and a test-suite driver. It is better to
# build a specialized interpreter with these facilities compiled in,
# see entries o/${HOSTTYPE}/book.{bigloo,gsc} below to regenerate
# them. You can also directly use an interpreter and load on the fly
# Meroonet and the test-suite driver every time.  This is what the
# MIT-based definition or the Gambit (gsi) based definition does.

# 2014 Note: book.gsc, the pre-compiled version of Gambit is not
# supported due to issues compiling scheme files with gsc when
# passing the -:s flag.  See the comment for the book.gsc target
# below.
#
# SCHEME = o/${HOSTTYPE}/book.gsc
#
# These schemes are the only known-working options. See the
# README.md file for more info.
#
#SCHEME = o/${HOSTTYPE}/book.bigloo
#SCHEME = o/${HOSTTYPE}/book.gsi
#SCHEME = o/${HOSTTYPE}/book.mit
SCHEME = o/${HOSTTYPE}/book.guile

# Guile and Mit-scheme's EVAL take a mandatory environment argument.
ifeq (${SCHEME}, o/${HOSTTYPE}/book.mit)
    EVAL_ENVIRONMENT = user-initial-environment
else ifeq (${SCHEME}, o/${HOSTTYPE}/book.guile)
    EVAL_ENVIRONMENT = (interaction-environment)
endif

# This variable allows to measure time.
# I personnally use Gnu time but time will do also.

TIME = time

# This is the make utility. This makefile uses a couple of GNU-make
# specific features. If you want to port to BSD make, just search
# for '$(shell' and '$(filter-out' and replace those with
# BSD-make-equivalent features.

MAKE = make

# A temporary file used to store temporary results. Put it in a
# place where it will disappear automatically sometime.

RESULTS = /tmp/result

# A temporary file used to store the names of failing tests when
# running the grand.test target.

FAILURES = /tmp/failures

# Make an archive grouping *.o files
# You need it if you want to test the Scheme towards C compiler.

AR = ar

# Updating an archive (void on some machines)
# You need it if you want to test the Scheme towards C compiler.

RANLIB = ranlib

# This is the C compiler I used as well as its preferred flags.
# You need it if you want to test the Scheme towards C compiler.

CC = gcc
CFLAGS = -ansi -pedantic -Wall -O

# This is perl. I use it for checking results of tests. It is not
# mandatory to setup this variable.

PERL = perl

# Absolute path to LiSP source root.
export LiSP_TOPDIR = ${CURDIR}

# Set the SHELL explicitly. Mit-scheme's run-shell-command respects
# this variable, and some shell commands will fail if using a
# non-standard shell (e.g. fish).
export SHELL := $(shell which sh)

# This part of the global Imakefile defines how to run and test the
# programs of the book.

##################################### Build specialized interpreters.
# Rebuild a Bigloo interpreter with Meroonet and tester in it.
# Adapted to Bigloo 4.1a. Due to name conflicts, the compilation of
# rtbook.scm emits much warnings: ignore them!

o/${HOSTTYPE}/book.bigloo : bigloo/book.scm o/${HOSTTYPE}/rtbook.a
	${BIGLOO} -v -call/cc -cg -o o/${HOSTTYPE}/book.bigloo bigloo/book.scm \
	    -ldopt o/${HOSTTYPE}/rtbook.a
	-rm bigloo/book.[co] o/${HOSTTYPE}/book.[co]

o/${HOSTTYPE}/rtbook.a : o/${HOSTTYPE}/rtbook.o common/pp.scm common/format.scm
	-rm o/${HOSTTYPE}/rtbook.a
	cd o/${HOSTTYPE} ; ${AR} cvr rtbook.a rtbook.o
	-${RANLIB} o/${HOSTTYPE}/rtbook.a

o/${HOSTTYPE}/rtbook.o : bigloo/rtbook.scm bigloo/hack.scm src/tester.scm

	-[ -d o/${HOSTTYPE} ] || ${MAKE} mkdir
	${BIGLOO} -c -v -call/cc -cg -w -o o/${HOSTTYPE}/rtbook.o bigloo/rtbook.scm
	-rm bigloo/rtbook.[co] o/${HOSTTYPE}/rtbook.c

# Default work for the distribution, create some sub-directories
# where will go compilation products.
build.interpreter : mkdir
	@if [ "X${SCHEME}" = X ] ; \
	    then echo "*** Unbound SCHEME variable, see Makefile" ; exit 1 ; \
	    else : ; fi

	case "${SCHEME}" in \
	    *bigloo|*gsi|*mit|*guile) ${MAKE} ${SCHEME} ;; \
	    *) : ;; esac

######################################## Test interpreters

test.interpreters : o/${HOSTTYPE}/book.bigloo.test o/${HOSTTYPE}/book.mit.test \
    o/${HOSTTYPE}/book.gsi.test o/${HOSTTYPE}/book.guile.test

MIT_BAND_FILE=o/${HOSTTYPE}/book.mit.com
${MIT_BAND_FILE} : mkdir
	echo "(disk-save \"${MIT_BAND_FILE}\" \"${MIT_BAND_FILE}\")" \
	| mit-scheme --batch-mode --no-init-file --load mitscheme/book.scm

# Makes a command to run mitscheme. Must be run from the current
# directory.
o/${HOSTTYPE}/book.mit : ${MIT_BAND_FILE}
	echo "#!/bin/sh" > $@
	echo "exec mit-scheme --band ${MIT_BAND_FILE} --eval '(start)'" >> $@
	chmod a=rwx $@

# Makes a command to run guile. Must be run from the current
# directory.
o/${HOSTTYPE}/book.guile : mkdir
	echo "#!/bin/sh" > $@
	echo "exec guile -q -l guile/book.scm" >> $@
	chmod a=rwx $@

# Makes a command for Gambit interpreter similar to the others.
# This command has to be run from the current directory.
o/${HOSTTYPE}/book.gsi : mkdir
	echo "#!/bin/sh" > o/${HOSTTYPE}/book.gsi
	echo "exec gsi -:s,d- gambit/book.scm" >> o/${HOSTTYPE}/book.gsi
	chmod a=rwx o/${HOSTTYPE}/book.gsi

# Compile for Gambit
# Gambit rules to find files are relative to previous ones (as in
# Mac) so change pathnames to absolute pathnames.
o/${HOSTTYPE}/book-gsc.scm : mkdir gambit/book.scm
	sed -e "s;include \";include \"`pwd`/;" < gambit/book.scm \
	    > o/${HOSTTYPE}/book-gsc.scm

o/${HOSTTYPE}/book-gsc.escm : o/${HOSTTYPE}/book-gsc.scm gambit/hooks.gsi
	cd o/${HOSTTYPE} ; ${GSC} -:s -expansion book-gsc.scm > book-gsc.escm
	more o/${HOSTTYPE}/book-gsc.escm

o/${HOSTTYPE}/book-gsc.c : o/${HOSTTYPE}/book-gsc.scm gambit/hooks.gsi
	cd o/${HOSTTYPE} ; ${GSC} -:s -link -verbose -report book-gsc.scm

# Due to a bug in gsc, compiling with the -:s appears to be broken.
# See the following threads for more info:
#
# http://comments.gmane.org/gmane.lisp.scheme.gambit/6980
# https://mercure.iro.umontreal.ca/pipermail/gambit-list/2013-October/007106.html
#
# TODO: check back on this and see if a fix has landed -- ma.
o/${HOSTTYPE}/book-gsc.o : o/${HOSTTYPE}/book-gsc.c
	cd o/${HOSTTYPE} ; ${GSC} -:s -obj book-gsc.c
o/${HOSTTYPE}/book-gsc_.o : o/${HOSTTYPE}/book-gsc.c
	cd o/${HOSTTYPE} ; ${GSC} -:s -obj book-gsc_.c
o/${HOSTTYPE}/book.gsc : o/${HOSTTYPE}/book-gsc.o
o/${HOSTTYPE}/book.gsc : o/${HOSTTYPE}/book-gsc_.o
	cd o/${HOSTTYPE} ; ${GSC} -:s -exe -o book.gsc book-gsc.o book-gsc_.o

check.results :
	@if grep -i '= done' ${RESULTS} ; \
	    then echo '*** Tests successfully passed ***' ; \
	    else echo '*** *** Abnormal results **** ***' ; exit 1 ; fi

o/${HOSTTYPE}/book.bigloo.test : o/${HOSTTYPE}/book.bigloo.test1
o/${HOSTTYPE}/book.bigloo.test : o/${HOSTTYPE}/book.bigloo.test2
o/${HOSTTYPE}/book.bigloo.test : o/${HOSTTYPE}/book.bigloo.test3
o/${HOSTTYPE}/book.bigloo.test : o/${HOSTTYPE}/book.bigloo.test4
o/${HOSTTYPE}/book.bigloo.test1 : o/${HOSTTYPE}/book.bigloo
	echo "(test \"src/syntax.tst\")" | o/${HOSTTYPE}/book.bigloo \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.bigloo.test2 : o/${HOSTTYPE}/book.bigloo
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.bigloo \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.bigloo.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.bigloo test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.bigloo.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.bigloo test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.gsi.test : o/${HOSTTYPE}/book.gsi.test1
o/${HOSTTYPE}/book.gsi.test : o/${HOSTTYPE}/book.gsi.test2
o/${HOSTTYPE}/book.gsi.test : o/${HOSTTYPE}/book.gsi.test3
o/${HOSTTYPE}/book.gsi.test : o/${HOSTTYPE}/book.gsi.test4
o/${HOSTTYPE}/book.gsi.test1 : o/${HOSTTYPE}/book.gsi
	echo "(test \"src/syntax.tst\")" | o/${HOSTTYPE}/book.gsi \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsi.test2 : o/${HOSTTYPE}/book.gsi
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.gsi \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsi.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.gsi test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsi.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.gsi test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.gsc.test : o/${HOSTTYPE}/book.gsc.test1
o/${HOSTTYPE}/book.gsc.test : o/${HOSTTYPE}/book.gsc.test2
o/${HOSTTYPE}/book.gsc.test : o/${HOSTTYPE}/book.gsc.test3
o/${HOSTTYPE}/book.gsc.test : o/${HOSTTYPE}/book.gsc.test4
o/${HOSTTYPE}/book.gsc.test1 : o/${HOSTTYPE}/book.gsc
	echo "(test \"src/syntax.tst\")" | o/${HOSTTYPE}/book.gsc \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsc.test2 : o/${HOSTTYPE}/book.gsc
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.gsc \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsc.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.gsc test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.gsc.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.gsc test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.mit.test : o/${HOSTTYPE}/book.mit.test1
o/${HOSTTYPE}/book.mit.test : o/${HOSTTYPE}/book.mit.test2
o/${HOSTTYPE}/book.mit.test : o/${HOSTTYPE}/book.mit.test3
o/${HOSTTYPE}/book.mit.test : o/${HOSTTYPE}/book.mit.test4
o/${HOSTTYPE}/book.mit.test1 : o/${HOSTTYPE}/book.mit
	echo "(test \"src/syntax.tst\")" | o/${HOSTTYPE}/book.mit \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.mit.test2 : o/${HOSTTYPE}/book.mit
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.mit \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.mit.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.mit test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.mit.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.mit test.chap2a | tee ${RESULTS}
	${MAKE} check.results

o/${HOSTTYPE}/book.guile.test : o/${HOSTTYPE}/book.guile.test1
o/${HOSTTYPE}/book.guile.test : o/${HOSTTYPE}/book.guile.test2
o/${HOSTTYPE}/book.guile.test : o/${HOSTTYPE}/book.guile.test3
o/${HOSTTYPE}/book.guile.test : o/${HOSTTYPE}/book.guile.test4
o/${HOSTTYPE}/book.guile.test1 : o/${HOSTTYPE}/book.guile
	echo "(test \"src/syntax.tst\")" | o/${HOSTTYPE}/book.guile \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.guile.test2 : o/${HOSTTYPE}/book.guile
	echo "(test \"meroonet/oo-tests.scm\")" | o/${HOSTTYPE}/book.guile \
		| tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.guile.test3 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.guile test.chap1 | tee ${RESULTS}
	${MAKE} check.results
o/${HOSTTYPE}/book.guile.test4 :
	${MAKE} SCHEME=o/${HOSTTYPE}/book.guile test.chap2a | tee ${RESULTS}
	${MAKE} check.results

########################## All the tests
# Some tests have a name starting with no. That means that the test
# has some problems (it does not complete or loops) I just verify
# that it ends at the expected point. Some test have a name starting
# with long. That means that it is a very long long test, so it is
# only run if the variable YOU_HAVE_TIME is true (not false).

YOU_HAVE_TIME = true

ALL_GRAND_TESTS = ${TEST_CHAP1} ${TEST_CHAP2} ${TEST_CHAP3} ${TEST_CHAP4} \
		  ${TEST_CHAP5} ${TEST_CHAP6} ${TEST_CHAP7} ${TEST_CHAP8} \
		  ${TEST_CHAP9} ${TEST_CHAP10}

GRAND_TEST_FLAGS = SCHEME="${SCHEME}" YOU_HAVE_TIME="${YOU_HAVE_TIME}" \
		   WHICH_TESTS="${WHICH_TESTS}"

# 2014 Note: BROKEN_TESTS represent tests that are still not passing
# in SCHEMEs that have otherwise been "fixed" (Bigloo, Gambit, and
# MIT). These are test for which I was not able to find a quick fix,
# and may require a non-trivial effort to get them working.  In the
# case of test.reflisp, this test was previously only supported in
# Bigloo, (src/chap8k.scm generated a divide-by-zero error when
# attempting to compile with anyting other than bigloo).
BROKEN_TESTS = test.reflisp

ifeq (${SCHEME}, o/${HOSTTYPE}/book.bigloo)
    BROKEN_TESTS += big.test.chap8j
endif

GRAND_TESTS = $(filter-out ${BROKEN_TESTS}, ${ALL_GRAND_TESTS})

# Test only parts of the grand tour of tests.
TMP_ALL_TESTS = ${TEST_CHAP9} ${TEST_CHAP10}

tmp.grand.test : WHICH_TESTS = ${TMP_ALL_TESTS}
grand.test : WHICH_TESTS = ${GRAND_TESTS}
grand.test tmp.grand.test:
	${TIME} nice ${MAKE} do.grand.test ${GRAND_TEST_FLAGS}

do.grand.test :
	@rm -f ${FAILURES}
	@for test in ${WHICH_TESTS} ; do \
	    ( echo Testing $$test ... ; ${MAKE} $$test ${GRAND_TEST_FLAGS} ) \
	    | tee ${RESULTS} ; echo Checking results of $$test ... ; \
	    ${PERL} perl/check.prl ${RESULTS} $$test ; \
	    [ $$? -ne 0 ] && echo $$test >> ${FAILURES} ; \
	done; echo "Finished grand.test"

	@[ -e ${FAILURES} ] && ( echo "The following tests failed:"; \
	    cat ${FAILURES} ) || echo "All tests passed."

grand.test.with.bigloo : o/${HOSTTYPE}/book.bigloo
	${MAKE} grand.test SCHEME=o/$$HOSTTYPE/book.bigloo TIME=time
grand.test.with.gsi : o/${HOSTTYPE}/book.gsi
	${MAKE} grand.test SCHEME=o/$$HOSTTYPE/book.gsi TIME=time
grand.test.with.mit : o/${HOSTTYPE}/book.mit
	${MAKE} grand.test SCHEME=o/$$HOSTTYPE/book.mit TIME=time
grand.test.with.guile : o/${HOSTTYPE}/book.guile
	${MAKE} grand.test SCHEME=o/$$HOSTTYPE/book.guile TIME=time

##################################### Chap 1 ##############################

TEST_CHAP1 = test.chap1

# chap1.scm contains a naive interpreter written in naive Scheme.
test.chap1 : src/chap1.scm
	echo \
	    '(load "src/chap1.scm")' \
	    '(and (test-scheme1 "src/scheme.tst")' \
	    '     (test-scheme1 "src/chap1.tst"))' \
	| ${SCHEME}

##################################### Chap 2 ##############################

TEST_CHAP2 = test.chap2a test.chap2b test.chap2c test.chap2e test.chap2f \
	     test.chap2g test.chap2h

# chap2a.scm contains a little Lisp2 interpreter (eval e env fenv).
# chap2d.scm displays simple cyclic lists in a finite way.
test.chap2a : src/chap2a.scm
	echo \
	    '(load "src/chap2a.scm")' \
	    '(and (test-chap2a "src/chap2a.tst")' \
	    '     (load "src/chap2d.scm")' \
	    "     'done)" \
	| ${SCHEME}

# chap2b.scm adds flet and function to the previous interpreter
src/chap2b.scm : src/chap2a.scm
test.chap2b : src/chap2b.scm
	echo \
	    '(load "src/chap2a.scm")' \
	    '(load "src/chap2b.scm")' \
	    '(test-scheme2a "src/chap2b.tst")' \
	| ${SCHEME}

# chap2c.scm adds dynamic variables (eval e env fenv denv)
src/chap2c.scm : src/chap2b.scm
test.chap2c : src/chap2c.scm
	echo \
	    '(load "src/chap2a.scm")' \
	    '(load "src/chap2b.scm")' \
	    '(load "src/chap2c.scm")' \
	    '(test-scheme2c "src/chap2c.tst")' \
	| ${SCHEME}

# chap2e.scm adds dynamic variables a la Common Lisp
src/chap2e.scm : src/chap2c.scm
test.chap2e : src/chap2e.scm
	echo \
	    '(load "src/chap2a.scm")' \
	    '(load "src/chap2b.scm")' \
	    '(load "src/chap2c.scm")' \
	    '(load "src/chap2e.scm")' \
	    '(test-scheme2c "src/chap2e.tst")' \
	| ${SCHEME}

# chap2f.scm adds dynamic variables without special forms
test.chap2f : src/chap2f.scm
	echo \
	    '(load "src/chap2f.scm")' \
	    '(test-scheme2f "src/chap2f.tst")' \
	| ${SCHEME}

# chap2g.scm adds the let, letrec special forms to chap1.scm (scheme)
src/chap2g.scm : src/chap1.scm
test.chap2g : src/chap2g.scm
	echo \
	    '(load "src/chap1.scm")' \
	    '(load "src/chap2g.scm")' \
	    '(and (test-scheme1 "src/scheme.tst")' \
	    '     (test-scheme1 "src/chap2g.tst"))' \
	| ${SCHEME}

# chap2h.scm allows extensions such as (1 e) or ((f1 f2) e)
src/chap2h.scm : src/chap1.scm
test.chap2h : src/chap2h.scm
	echo \
	    '(load "src/chap1.scm")' \
	    '(load "src/chap2h.scm")' \
	    '(and (test-scheme1 "src/scheme.tst")' \
	    '     (test-scheme1 "src/chap2h.tst"))' \
	| ${SCHEME}

##################################### Chap 3 ##############################

TEST_CHAP3 = test.chap3f test.chap3h

# chap3{a,b,c,d,e}.scm contain excerpts from chapter3 (not necessarily
# Scheme).

# chap3f.scm contains an interpreter in OO style
test.chap3f : src/chap3g.scm
	echo \
	    '(load "src/chap3f.scm")' \
	    '(load "src/chap3g.scm")' \
	    '(load "src/chap3h.scm")' \
	    '(test-scheme3f "src/scheme.tst")' \
	| ${SCHEME}

# chap3g.scm defines additional control features (block, catch)
# chap3h.scm defines unwind-protect
# chap3j.scm improves chap3f.scm
src/chap3g.scm : src/chap3f.scm
src/chap3h.scm : src/chap3f.scm
src/chap3j.scm : src/chap3f.scm
test.chap3h : src/chap3g.scm
	echo \
	    '(load "src/chap3f.scm")' \
	    '(load "src/chap3g.scm")' \
	    '(load "src/chap3h.scm")' \
	    '(load "src/chap3j.scm")' \
	    '(and (test-scheme3f "src/scheme.tst")' \
	    '     (test-scheme3f "src/chap3f.tst"))' \
	| ${SCHEME}

##################################### Chap 4 ##############################

TEST_CHAP4 = test.chap4

# chap4.scm contains excerpts from chapter 4
# chap4a.scm contains a Scheme interpreter coded with nothing but closures.
test.chap4 : src/chap4.scm src/chap4a.scm src/chap4.tst
	echo \
	    '(load "src/chap4.scm")' \
	    '(load "src/chap4a.scm")' \
	    "(define box1 'wait)" \
	    "(define p1 'wait)" \
	    '(and (file-test "src/scheme.tst")' \
	    '     (set! evaluate new-evaluate)' \
	    '     (file-test "src/chap4a.tst")' \
	    '     (suite-test' \
	    '       "src/chap4.tst" "?? " "== " #t' \
	    '       (lambda (read check err)' \
	    "         (lambda () (check (eval (read) ${EVAL_ENVIRONMENT}))))" \
	    '       naive-match))' \
	| ${SCHEME}

##################################### Chap 5 ##############################
# Denotational semantics

TEST_CHAP5 = test.chap5a loop.test.chap5b test.chap5c test.chap5d test.chap5e \
	     test.chap5f test.chap5g test.chap5h

bench.chap5 : bench.chap5a

test.chap5a : src/chap5a.scm
	echo \
	    '(load "src/chap5a.scm")' \
	    '(test-denScheme "src/scheme.tst")' \
	| ${SCHEME}

# See typical times a the end of src/chap5-bench.scm
bench.chap5a : src/chap5a.scm
	echo \
	    '(load "src/chap5a.scm")' \
	    '(bench "src/chap5-bench.scm")' \
	| ${TIME} ${SCHEME}

# Lambda calculus denotation
# The last tests loop due to applicative order.
loop.test.chap5b :
	-echo skip that test or run it by hand : ${MAKE} test.chap5b
test.chap5b : src/chap5b.scm
	echo \
	    '(load "src/chap5b.scm")' \
	    '(test-L "src/chap5b.tst")' \
	| ${SCHEME}

# Scheme + dynamic variables denotational interpreter
test.chap5c : src/chap5c.scm
	echo \
	    '(load "src/chap5c.scm")' \
	    '(and (test-denScheme "src/scheme.tst")' \
	    '     (test-denScheme "src/chap5c.tst"))' \
	| ${SCHEME}

# Same as chap5c except that this one tries to precompute meanings.
# This is slightly faster than chap5a.
test.chap5d : src/chap5d.scm
	echo \
	    '(load "src/chap5d.scm")' \
	    '(test-denScheme "src/scheme.tst")' \
	| ${SCHEME}

bench.chap5d : src/chap5d.scm src/chap5-bench.scm
	echo \
	    '(load "src/chap5d.scm")' \
	    '(bench "src/chap5-bench.scm")' \
	| ${TIME} ${SCHEME}

# Modify the denotational interpreter chap5d to specify that
# the evaluation order is unspecified.
test.chap5e : src/chap5e.scm
	echo \
	    '(load "src/chap5d.scm")' \
	    '(load "src/chap5e.scm")' \
	    '(test-den+Scheme "src/chap5e.tst")' \
	| ${SCHEME}

# CPS without any tests.
test.chap5f : src/chap5f.scm
	echo \
	    '(and (load "src/chap5f.scm")' \
	    "     'done)" \
	| ${SCHEME}

# Same as chap5d with an explicit global environment.
test.chap5g : src/chap5g.scm
	echo \
	    '(load "src/chap5g.scm")' \
	    '(and (test-denScheme "src/scheme.tst")' \
	         '(test-denScheme "src/chap5g.tst"))' \
	| ${SCHEME}

# Unordered evaluation order simulated with random.
test.chap5h : src/chap5h.scm
	echo \
	    '(load "src/chap5h.scm")' \
	    '(load "src/chap1.scm")' \
	    '(test-scheme1 "src/scheme.tst")' \
	| ${SCHEME}

##################################### Chap 6 ##############################
# Chapter on fast interpretation (by means of precompilation)

TEST_CHAP6 = test.chap6a test.chap6b test.chap6c test.chap6d \
	     shared.test.chap6dd test.chap6e dynext.test.chap6f test.chap6g \
	     test.chap6h

bench.chap6 : bench.chap6a bench.chap6b bench.chap6c bench.chap6d bench.chap6e

test.chap6.bgl : test.chap6a.bgl

# Fast interpretation, code is precompiled into (lambda (sr k)..)
test.chap6a : src/chap6a.scm
	echo \
	    '(load "src/chap6a.scm")' \
	    '(test-scheme6a "src/scheme.tst")' \
	| ${SCHEME}

# Interpreted bench
bench.chap6a : src/chap6a.scm
	echo \
	    '(load "src/chap6a.scm")' \
	    '(bench6a 1 (call-with-input-file "src/chap5-bench.scm" read))' \
	| ${SCHEME}

# Compiled bench with Bigloo
test.chap6a.bgl : o/${HOSTTYPE}/rtbook.a o/${HOSTTYPE}/bglchap6a
	${TIME} o/${HOSTTYPE}/bglchap6a 10

o/${HOSTTYPE}/bglchap6a : src/chap6a.scm bigloo/compapp.scm
	echo \
	    '(load "bigloo/compapp.scm")' \
	    '(define the-bench (call-with-input-file "src/chap5-bench.scm" read))' \
	    '(compile-bigloo-application '\
	    '  "${BIGLOO}" "o/${HOSTTYPE}/" "bglchap6a" ' \
	    "  `(bench6a (string->number (cadr command-options)) ',the-bench)" \
	    '  "src/chap6a.scm")' \
	| ${SCHEME}

# Testing the same fast interpreter with Bigloo (intepreted)
test.chap6.bgl :
	echo \
	    "(define primes " \
	    " (lambda (n f max)" \
	    "    ((lambda (filter) " \
	    "       (begin " \
	    "          (set! filter (lambda (p) (lambda (n) (= 0 (remainder n p)))))" \
	    "          (if (> n max)" \
	    "              '()" \
	    "              (if (f n)" \
	    "                  (primes (+ n 1) f max)" \
	    "                  (cons n ((lambda (ff)" \
	    "                             (primes (+ n 1)" \
	    "                                     (lambda (p) (if (f p) #t (ff p)))" \
	    "                                     max))" \
	    "                           (filter n)))))))" \
	    "     'wait)))" \
	    "(define (bench factor)" \
	    "  (let loop ((factor factor))" \
	    "    (let ((v (eval '(primes 2 (lambda (x) #f) 50))))" \
	    "      (if (> factor 1)" \
	    "        (loop (- factor 1))" \
	    "        (display v)))))" \
	    "(bench 100)" \
	| ${TIME} bigloo -i

# Compare also with CAML light
test.chap6.ml :
	echo \
	    "let rec primes n f max =" \
	    "  let filter p n = (0 = n mod p) in" \
	    "    if (n > max) then" \
	    "      []" \
	    "    else if (f n) then" \
	    "      primes (n+1) f max" \
	    "    else" \
	    "      n :: let ff = (filter n) in" \
	    "             primes (n+1)" \
	    "                    (function p -> if (f p) then true else (ff p))" \
	    "                    max;;" \
	    "let bench factor =" \
	    "  let rec loop factor =" \
	    "    let v = primes 2 (fun x -> false) 50 in" \
	    "      if (factor > 1) then" \
	    "        loop (factor-1)" \
	    "      else" \
	    "        v" \
	    "  in" \
	    "    loop factor;; " \
	    "bench 100;;" \
	    | ${TIME} camllight

# patch to chap6a.scm to define new global variables on the fly:
test.chap6b : src/chap6a.scm src/chap6b.scm
	echo \
	    '(load "src/chap6a.scm")' \
	    '(load "src/chap6b.scm")' \
	    '(and (test-scheme6b "src/chap6b.tst")' \
	    '     (test-scheme6b "src/scheme.tst"))' \
	| ${SCHEME}

# Interpreted bench
bench.chap6b : src/chap6a.scm src/chap6b.scm
	echo \
	    '(load "src/chap6a.scm")' \
	    '(load "src/chap6b.scm")' \
	    '(bench6a 1 (call-with-input-file "src/chap5-bench.scm" read))' \
	| ${SCHEME}

# Environment is now held in a global variable *env*.
# Programs are precompiled into (lambda (k) ...)
test.chap6c : src/chap6c.scm
	echo \
	    '(load "src/chap6a.scm")' \
	    '(load "src/chap6c.scm")' \
	    '(test-scheme6c "src/scheme.tst")' \
	| ${SCHEME}

# Interpreted bench
bench.chap6c : src/chap6c.scm
	echo \
	    '(load "src/chap6a.scm")' \
	    '(load "src/chap6c.scm")' \
	    '(bench6c 1 (call-with-input-file "src/chap5-bench.scm" read))' \
	| ${SCHEME}

# Make continuation implicit.
# The program is precompiled into (lambda ()...)
test.chap6d : src/chap6d.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(test-scheme6d "src/scheme.tst")' \
	| ${SCHEME}

# Interpreted bench
bench.chap6d : src/chap6d.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(bench6d 1 (call-with-input-file "src/chap5-bench.scm" read))' \
	| ${SCHEME}

# Variant with pre-allocated frames (work for Lisp not for Scheme)
# An error is expected on one of the lattest tests on call/cc. This
# test is preceded by the string "The following test forces a
# continuation to return multiply."
shared.test.chap6dd : test.chap6dd
test.chap6dd : src/chap6d.scm src/chap6dd.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap6dd.scm")' \
	    '(and (test-scheme6d "src/chap6dd.tst")' \
	    '     (test-scheme6d "src/scheme.tst"))' \
	| ${SCHEME}

# a small byte-tree-code compiler. (Not used in the book)
test.chap6e : src/chap6e.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap6e.scm")' \
	    '(test-scheme6e "src/scheme.tst")' \
	| ${SCHEME}

bench.chap6e : src/chap6e.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap6e.scm")' \
	    '(bench6e 1 (call-with-input-file "src/chap5-bench.scm" read))' \
	| ${SCHEME}

# chap6e is very dependent on tests on types in byte-eval
# but faster than Scheme->C.

########### Skip chap6f which was superseded by chap10.
# Small compiler towards C (not in the book but still working). This
# compiler uses a different pattern of C generation and a variant
# for environment management. That's why I leave it here. It is
# grafted to the precompiler similarly to the bytecode compiler.
# ATTENTION, this is a very long test. This test fails on
# continuation used out of their dynamic extent (no full
# continuation a la Scheme).
long.dynext.test.chap6f :
	if ${YOU_HAVE_TIME} ; then ${MAKE} dynext.test.chap6f ; else : ; fi
dynext.test.chap6f : test.chap6f
test.chap6f : o/${HOSTTYPE}/rt.o src/chap6f.scm
	echo \
	    '(load "src/chap6f.scm")' \
	    '(test-scheme "src/scheme.tst")' \
	| ${SCHEME}

# start an interpreter to interactively compile towards C.
#
# The (scheme) toplevel reads an expression and shows the generated
# C.  This test fails on continuation used out of their dynamic
# extent (no full continuation a la Scheme).
start.chap6f : o/${HOSTTYPE}/rt.o src/chap6f.scm
	@(echo '(load "src/chap6f.scm") (scheme)' ; tee ) | ${SCHEME}

# A little bench to appreciate the compiler speed. (obsolete)
bench.chap6f : o/${HOSTTYPE}/chap6f-bench
	${TIME} o/${HOSTTYPE}/chap6f-bench

export CaFLAGS = -I${LiSP_TOPDIR}/src/c ${CFLAGS}

o/${HOSTTYPE}/chap6f-bench.c : src/chap6f.scm src/chap5-bench.scm
	echo \
	    '(loadq "src/chap6f.scm")' \
	    '(compile-file "src/chap5-bench.scm" "o/${HOSTTYPE}/tt.c")' \
	| ${SCHEME} -sch 8
	-indent o/${HOSTTYPE}/tt.c

# The runtime in C for that compiler. Generates a lot of warnings...
# superseded by the new library src/c/scheme*.[ch] (but this one
# contains a GC).
o/${HOSTTYPE}/rt.o : src/c/rt.c src/c/rt.h
	cd o/${HOSTTYPE} ; ${CC} -c ${CaFLAGS} ../../src/c/rt.c
o/${HOSTTYPE}/chap6f-bench : o/${HOSTTYPE}/chap6f-bench.c
o/${HOSTTYPE}/chap6f-bench : src/c/rt.h o/${HOSTTYPE}/rt.o
	cd o/${HOSTTYPE} ; ${CC} -o tt ${CaFLAGS} chap6f-bench.c rt.o

########### end of chap6f which was superseded by chap10. (obsolete)

# Handling the define special form.
test.chap6g : src/chap6a.scm src/chap6b.scm src/chap6g.scm
	echo \
	    '(load "src/chap6a.scm")' \
	    '(load "src/chap6b.scm")' \
	    '(load "src/chap6g.scm")' \
	    '(and (test-scheme6b "src/chap6g.tst")' \
	    '     (test-scheme6b "src/scheme.tst"))' \
	| ${SCHEME}

# exercice on a specialized invocation protocol for thunks
test.chap6h : src/chap6d.scm src/chap6h.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap6h.scm")' \
	    '(test-scheme6d "src/scheme.tst")' \
	| ${SCHEME}

##################################### Chap 7 ##############################
# Bytecode compilation

TEST_CHAP7 = test.chap7a test.chap7b test.chap7c test.chap7d test.chap7e \
	     test.chap7g test.chap7h shallow.test.chap7i

# Linearize the intermediate language to make register *val* appear.
test.chap7a : src/chap6d.scm src/chap7a.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7a.scm")' \
	    '(test-scheme7a "src/scheme.tst")' \
	| ${SCHEME}

# make stack appear (as well as other registers)
test.chap7b : src/chap6d.scm src/chap7b.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7b.scm")' \
	    '(test-scheme7b "src/scheme.tst")' \
	| ${SCHEME}

# represents instructions by list of closures. Make register PC
# appear.
test.chap7c : src/chap6d.scm src/chap7c.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7c.scm")' \
	    '(test-scheme7c "src/scheme.tst")' \
	| ${SCHEME}

# the complete bytecode compiler itself.
# The instruction set is defined in chap7f but is directly
# handled by chap7d.
test.chap7d : src/chap6d.scm src/chap7d.scm src/chap7f.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(test-scheme7d "src/scheme.tst")' \
	| ${SCHEME}

# added bind-exit, dynamic variables and error handling (first version
# with dynenv register) in the bytecode compiler.
test.chap7e : src/chap7d.scm src/chap7e.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7e.scm")' \
	    '(and (test-scheme7e "src/scheme.tst")' \
	    '     (test-scheme7e "src/chap7d.tst")' \
	    '     (test-scheme7e "src/chap5c.tst"))' \
	| ${SCHEME}

# chap7f.scm contains the definition of the instructions of the machine

# separate compilation stuff, link compiled files, build stand-alone
# with the bytecode compiler.
test.chap7g : src/chap7h.scm src/chap7g.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7g.scm")' \
	    '(and (test-scheme7g "src/scheme.tst")' \
	    '     (test-scheme7g "src/chap7d.tst")' \
	    '     (test-scheme7g "src/chap5c.tst"))' \
	    '(compile-file "tmp.si/foo")' \
	    '(run-application 100 "tmp.si/foo.so")' \
	    '(compile-file "tmp.si/fact")' \
	    '(compile-file "tmp.si/fib")' \
	    '(compile-file "tmp.si/after")' \
	    '(build-application' \
	    '  "tmp.si/a.out" "tmp.si/fact" "tmp.si/fib" "tmp.si/foo" "tmp.si/after")' \
	    '(run-application 400 "tmp.si/a.out")' \
	    '(build-application-renaming-variables' \
	    '  "tmp.si/na.out" "tmp.si/a.out"' \
	    "  '((fib fact) (fact fib)))" \
	    '(run-application 400 "tmp.si/na.out")' \
	    "(assoc 'long-goto (disassemble *code*))" \
	| ${SCHEME}

# implementation variant for dynamic variables, error handlers
# with labels in the stack (without dynenv register).
test.chap7h : src/chap7d.scm src/chap7h.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(and (test-scheme7h "src/scheme.tst")' \
	    '     (test-scheme7h "src/chap7d.tst")' \
	    '     (test-scheme7h "src/chap5c.tst"))' \
	| ${SCHEME}

# shallow binding for dynamic variables
# It will fail on the last test of src/chap7d.tst
shallow.test.chap7i : test.chap7i
test.chap7i : src/chap7h.scm
	echo \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7i.scm")' \
	    '(and (test-scheme7h "src/scheme.tst")' \
	    '     (test-scheme7h "src/chap5c.tst")' \
	    '     (test-scheme7h "src/chap7d.tst"))' \
	| ${SCHEME}

##################################### Chap 8 ##############################
# Chapter on evaluation and reflection

TEST_CHAP8 = test.chap8a test.chap8b test.chap8c test.chap8d evalf.test.chap8e \
	     evalf.test.chap8f evalf.test.chap8g test.chap8h test.chap8i \
	     big.test.chap8j test.reflisp

# add eval/ce (as a special form) to the naive interpreter of chapter 1.
test.chap8a : src/chap8a.scm src/chap1.scm
	echo \
	    '(load "src/chap1.scm")' \
	    '(load "src/chap8a.scm")' \
	    '(and (test-scheme1 "src/scheme.tst")' \
	    '     (test-program "src/chap8.tst")' \
	    '     (set! set-global-value! dynamic-set-global-value!)' \
	    '     (test-scheme1 "src/chap8a.tst"))' \
	| ${SCHEME}

# Add eval/ce (as a special form) to the predenotational interpreter
# (with closures everyhere) seen in chapter 4.
test.chap8b : src/chap8b.scm src/chap4a.scm
	echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap4a.scm")' \
	    '(load "src/chap8b.scm")' \
	    '(and (file-test "src/scheme.tst")' \
	    '     (file-test "src/chap8a.tst"))' \
	| ${SCHEME}

# Add eval/ce (as a special form) to the threaded interpreter of
# chapter 6.
test.chap8c : src/chap8c.scm src/chap6d.scm
	echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap8c.scm")' \
	    '(and (test-scheme6d "src/scheme.tst")' \
	    '     (test-scheme6d "src/chap8a.tst"))' \
	| ${SCHEME}

# Add eval/ce (as a special form) to the bytecode compiler
test.chap8d : src/chap8c.scm src/chap8d.scm src/chap6d.scm
	echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7g.scm")' \
	    '(load "src/chap8d.scm")' \
	    '(and (test-scheme7g "src/scheme.tst")' \
	    '     (test-scheme7g "src/chap5c.tst")' \
	    '     (test-scheme7g "src/chap7d.tst")' \
	    '     (test-scheme7g "src/chap8a.tst"))' \
	| ${SCHEME}

# add eval/at (a function) as a function to the naive interpreter
# It fails on a test preceded by "eval as a function will fail..."
evalf.test.chap8e : src/chap8e.scm src/chap1.scm
	echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap1.scm")' \
	    '(load "src/chap8e.scm")' \
	    '(and (test-scheme1 "src/scheme.tst")' \
	    '     (test-scheme1 "src/chap8a.tst"))' \
	| ${SCHEME}

# add eval/at (a function) to the bytecode compiler.
# It fails on a test preceded by "eval as a function will fail..."
evalf.test.chap8f : src/chap8f.scm
	echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7g.scm")' \
	    '(load "src/chap8f.scm")' \
	    '(and (test-scheme7g "src/scheme.tst")' \
	    '     (test-scheme7g "src/chap5c.tst")' \
	    '     (test-scheme7g "src/chap7d.tst")' \
	    '     (test-scheme7g "src/chap8a.tst"))' \
	| ${SCHEME}

# represent interpreted functions as functions in the naive interpreter.
# It fails on a test preceded by "eval as a function will fail..."
evalf.test.chap8g : src/chap8g.scm src/chap1.scm
	echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap1.scm")' \
	    '(load "src/chap8g.scm")' \
	    '(and (test-scheme1 "src/scheme.tst")' \
	    '     (test-scheme1 "src/chap8a.tst"))' \
	| ${SCHEME}

# Add the export special form and a binary function eval/b,
# also add procedure->body and procedure->environment.
test.chap8h : src/chap8h.scm
	echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7g.scm")' \
	    '(load "src/chap8h.scm")' \
	    '(and (test-scheme7g "src/scheme.tst")' \
	    '     (test-scheme7g "src/chap5c.tst")' \
	    '     (test-scheme7g "src/chap7d.tst")' \
	    '     (test-scheme7g "src/chap8h.tst"))' \
	| ${SCHEME}

# add the import special form
test.chap8i : src/chap8i.scm
	echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7g.scm")' \
	    '(load "src/chap8h.scm")' \
	    '(load "src/chap8i.scm")' \
	    '(and (test-scheme7g "src/scheme.tst")' \
	    '     (test-scheme7g "src/chap5c.tst")' \
	    '     (test-scheme7g "src/chap7d.tst")' \
	    '     (test-scheme7g "src/chap8h.tst")' \
	    '     (test-scheme7g "src/chap8i.tst"))' \
	| ${SCHEME}

# a little reflective interpreter.
# Pay attention, this is very long and needs much much space...
long.test.chap8j :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap8j ; else : ; fi
big.test.chap8j : test.chap8j
test.chap8j : src/chap8h.scm si/reflisp.scm
	( echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7g.scm")' \
	    '(load "src/chap8h.scm")' \
	    '(load "src/chap8j.scm")' \
	    '(call-with-input-file' \
	    '  "si/reflisp.scm"' \
	    '  (lambda (in)' \
	    '    (let ((e (read in)))' \
	    '      (call-with-output-file' \
	    '        "tmp.si/tmp.scm"' \
	    '        (lambda (out)' \
	    "          (write \`((lambda (reflisp-code) ,e) ',e) out)" \
	    '          (newline out))))))' \
	    '(compile-file "tmp.si/tmp")' \
	    '(build-application "tmp.si/a.out" "tmp.si/tmp")' \
	    '(display `(byte-size is ,(vector-length *code*)))' \
	    '(newline)' \
	    '(and (run-application 400 "tmp.si/a.out")' \
	    "     'done)" \
	    ; cat src/chap8j.tst ) \
	| ${SCHEME}

tmp.test.chap8j :
	( echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7g.scm")' \
	    '(load "src/chap8h.scm")' \
	    '(load "src/chap8j.scm")' \
	    '(and (run-application 400 "tmp.si/a.out")' \
	    "     'done)" \
	    ; cat src/chap8j.tst ) \
	| ${SCHEME}

# a direct test of the reflective interpreter
test.reflisp : si/reflisp.scm src/chap8k.scm
	( echo \
	    '(load "src/chap8a.scm")' \
	    '(load "src/chap6d.scm")' \
	    '(load "src/chap7d.scm")' \
	    '(load "src/chap7h.scm")' \
	    '(load "src/chap7g.scm")' \
	    '(load "src/chap8h.scm")' \
	    '(load "src/chap8j.scm")' \
	    '(load "src/chap8k.scm")' \
	    '(begin' \
	    '  (display `(cons-size is ,(count-pairs reflisp-code)))' \
	    '  (newline))' \
	    "(and (reflisp) 'done)" \
	    ; cat src/chap8j.tst ) \
	| ${SCHEME}

##################################### Chap 9 #############################
# Chapter on macros

TEST_CHAP9 = test.chap9c

# A macro system (hygien if I want it, where I want it).
test.chap9c : src/chap9c.scm
	echo \
	    '(load "src/chap9c.scm")' \
	    '(load "src/chap9d.scm")' \
	    '(load "src/chap9e.scm")' \
	    '(and (test-scheme9d "src/scheme.tst")' \
	    '     (test-scheme9d "src/chap9c.tst"))' \
	| ${SCHEME}

##################################### Chap 10 #############################
# Chapter on compilation -> C

TEST_CHAP10 = test.chap10a test.chap10c dynext.test.chap10e test.chap10k \
	      dynext.test.chap10je test.chap10jk

# chap10a.scm: objectification
# chap10b.scm: small interpreter for objectified code
test.chap10a : src/chap10a.scm src/chap10b.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10b.scm")' \
	    '(and (test-scheme10b "src/scheme.tst"))' \
	| ${SCHEME}

# chap10c.scm: extract and globalize quotations
# chap10d.scm: interpret the objectified code
test.chap10c : src/chap10a.scm src/chap10b.scm
test.chap10c : src/chap10c.scm src/chap10d.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10b.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10d.scm")' \
	    '(and (test-scheme10b "src/scheme.tst"))' \
	| ${SCHEME}

all-o = o/${HOSTTYPE}/scheme.o o/${HOSTTYPE}/schemelib.o \
	o/${HOSTTYPE}/schemeklib.o

o/${HOSTTYPE}/scheme.o : src/c/scheme.h src/c/scheme.c
	cd o/${HOSTTYPE} ; ${CC} ${CFLAGS} -c ../../src/c/scheme.c
o/${HOSTTYPE}/schemelib.o : src/c/scheme.h src/c/schemelib.c
	cd o/${HOSTTYPE} ; ${CC} ${CFLAGS} -c ../../src/c/schemelib.c
o/${HOSTTYPE}/schemeklib.o : src/c/scheme.h src/c/schemeklib.c
	cd o/${HOSTTYPE} ; ${CC} ${CFLAGS} -c ../../src/c/schemeklib.c

# chap10e.scm: C generation
# chap10g.scm: lifting, quotation extraction.
# chap10h.scm: predefined environment
# chap10f.scm: tests on test-suites
# This test is very long... but it fails on continuations that are used
# out of their dynamic extent or multiply.
long.dynext.test.chap10e :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap10e ; else : ; fi
dynext.test.chap10e : test.chap10e
test.chap10e : src/chap10a.scm src/chap10c.scm
test.chap10e : src/chap10g.scm src/chap10e.scm
test.chap10e : src/chap10h.scm src/chap10f.scm
test.chap10e : o/${HOSTTYPE}/scheme.o
test.chap10e : o/${HOSTTYPE}/schemelib.o
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(and (test-scheme10e "src/chap10e.tst")' \
	    '     (test-scheme10e "src/scheme.tst"))' \
	| ${SCHEME}

# chap10m.scm contains the letify function that recursively copies
# an AST into a pure tree, trying to insert let forms.  This test is
# very long... but it fails on continuations that are used out of
# their dynamic extent or multiply.
long.dynext.test.chap10n :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap10n ; else : ; fi
dynext.test.chap10n : test.chap10n
test.chap10n : src/chap10m.scm src/chap10n.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(load "src/chap10m.scm")' \
	    '(load "src/chap10n.scm")' \
	    '(and (test-scheme10e "src/chap10e.tst")' \
	    '     (test-scheme10e "src/scheme.tst"))' \
	| ${SCHEME}

# Generate the C code corresponding to the running example of
# chapter 10. The C code will be left in o/chap10ex.c
chap10e.example : src/c/chap10ex.c
src/c/chap10ex.c : src/chap10ex.scm src/chap10e.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(set! *cc+cflags* "${CC} ${CFLAGS}")' \
	    '(call-with-input-file' \
	    '  "src/chap10ex.scm"' \
	    '  (lambda (in) (test-expression (read in))))' \
	| ${SCHEME}

	size o/${HOSTTYPE}/chap10e
	emacs -batch -l el/c-indent.el
	mv o/chap10e.c src/c/chap10ex.c

# This is the best I can to show the expanded version of the file.
# It needs to be hacked a little by hand before being inserted in
# the book.
src/c/chap10ex.E : perl/indent-E.prl perl/preindent.prl
src/c/chap10ex.E : src/c/chap10ex.c src/c/scheme.h
	perl/preindent.prl < src/c/scheme.h > /tmp/scheme.h
	cp src/c/chap10ex.c /tmp/chap10ex.c
	cd /tmp ; ${CC} ${CFLAGS} -E chap10ex.c -o chap10ex.E
	perl/indent-E.prl < /tmp/chap10ex.E > src/c/chap10ex.E
	rm /tmp/scheme.h /tmp/chap10ex.[Ec]
	indent src/c/chap10ex.E

# Compile this compiler with Bigloo
#
# I patched a little the o/${HOSTTYPE}/LiSPbookc.bgl file because of
# a bug on write on strings containing \". To be solved.
o/${HOSTTYPE}/LiSPbookc :
	H_DIR=`pwd`/src/c/ ; export H_DIR ; \
	A_FILE=`pwd`/o/${HOSTTYPE}/rtbook.a ; export A_FILE ; \
	echo \
	'(load "bigloo/compapp.scm")' \
	"'(set! *verbose* #t)" \
	'(compile-bigloo-application' \
	'  "${BIGLOO}" "o/${HOSTTYPE}/" "LiSPbookc"' \
	" '(begin" \
	'    (set! *h-dir* "$$H_DIR")' \
	'    (set! *rtbook-library* "$$A_FILE")' \
	'    (compiler-entry-point command-options))' \
	'  "src/chap10a.scm"' \
	'  "src/chap10c.scm"' \
	'  "src/chap10g.scm"' \
	'  "src/chap10e.scm"' \
	'  "src/chap10h.scm"' \
	'  "src/chap10f.scm")' \
    | ${SCHEME}

# The following entries do not work since the rtbook.a library is
# not sufficient: IO operations are missing.
#
# Compile the compiler with itself (stage 2)
o/${HOSTTYPE}/LiSPbookc2 : o/${HOSTTYPE}/LiSPbookc ${TIME}
	o/${HOSTTYPE}/LiSPbookc o/${HOSTTYPE}/LiSPbookc.bgl -v -o
	o/${HOSTTYPE}/LiSPbookc2 -C o/${HOSTTYPE}/LiSPbookc2.c

# Recompile the compiler with itself (stage 3)
o/${HOSTTYPE}/LiSPbookc3 : o/${HOSTTYPE}/LiSPbookc2
	${TIME} o/${HOSTTYPE}/LiSPbookc2 o/${HOSTTYPE}/LiSPbookc.bgl -v \
	    -o o/${HOSTTYPE}/LiSPbookc3 -C o/${HOSTTYPE}/LiSPbookc3.c

LiSPbookc.compare : o/${HOSTTYPE}/LiSPbookc3
	ls -l o/${HOSTTYPE}/LiSPbookc*[23].c
	diff o/${HOSTTYPE}/LiSPbookc*[23].c | wc
	size o/${HOSTTYPE}/LiSPbookc*[23]

# chap10i.scm : *Untested* variants for function invokation since it
# requires a change in SCM_invoke (in scheme.c).  This test is very
# long... but it fails on continuations that are used out of their
# dynamic extent or multiply.
long.dynext.test.chap10i :
	if ${YOU_HAVE_TIME} ; then ${MAKE} dynext.test.chap10i ; else : ; fi
dynext.test.chap10i : test.chap10i
test.chap10i : src/chap10a.scm src/chap10c.scm
test.chap10i : src/chap10g.scm src/chap10e.scm
test.chap10i : src/chap10h.scm src/chap10f.scm src/chap10i.scm
test.chap10i : o/${HOSTTYPE}/scheme.o
test.chap10i : o/${HOSTTYPE}/schemelib.o
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(load "src/chap10i.scm")' \
	    '(and (test-scheme10e "src/scheme.tst")' \
	    '     (test-scheme10e "src/chap10e.tst"))' \
	| ${SCHEME}

# as for various interpreters, try our usual bench.
# Compile it and run it.
chap10e.bench : o/${HOSTTYPE}/scheme.o
chap10e.bench : o/${HOSTTYPE}/schemelib.o
chap10e.bench : src/chap5-bench.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(call-with-input-file' \
	    '  "src/chap5-bench.scm"' \
	    '  (lambda (in) (test-expression (read in))))' \
	| ${SCHEME}

	${TIME} o/${HOSTTYPE}/chap10e

# Start a compiler.
# You can try (test-expression e) or (show-C-expression e).
# See file chap10f.scm for other possibilities.
start.chap10e : ${all-o}
	( echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    ; tee ) \
	| ${SCHEME}

# test indepently a compiled file o/chap10e.c.
test.chap10e.c : ${all-o}
	cd o/${HOSTTYPE} ; \
	${CC} ${CaFLAGS} ../chap10e.c scheme.o schemelib.o -o chap10e \
	&& ./chap10e

# chap10k.scm : CPS transformation, use schemeklib.c
# Very long test but it does not fail on call/cc tests.
long.test.chap10k :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap10k ; else : ; fi
test.chap10k : o/${HOSTTYPE}/scheme.o
test.chap10k : o/${HOSTTYPE}/schemeklib.o
test.chap10k : src/chap10k.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(load "src/chap10k.scm")' \
	    '(load "src/chap10m.scm")' \
	    '(and (test-scheme10k "src/scheme.tst")' \
	    '     (test-scheme10k "src/chap10k.tst")' \
	    '     (test-scheme10k "src/chap10e.tst"))' \
	| ${SCHEME}

# Test chap10k by direct interpretation (obsolete)
test.chap10l : src/chap10l.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10b.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10d.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(load "src/chap10k.scm")' \
	    '(load "src/chap10m.scm")' \
	    '(load "src/chap10l.scm")' \
	    '(and (test-scheme10b "src/scheme.tst")' \
	    '     (test-scheme10b "src/chap10k.tst")' \
	    '     (test-scheme10b "src/chap10e.tst"))' \
	| ${SCHEME}

# as for various interpreters, try our usual bench.
chap10k.bench : o/${HOSTTYPE}/scheme.o
chap10k.bench : o/${HOSTTYPE}/schemeklib.o
chap10k.bench : src/chap5-bench.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(load "src/chap10k.scm")' \
	    '(load "src/chap10m.scm")' \
	    '(set! *a.out* "chap10k")' \
	    '(call-with-input-file' \
	    '  "src/chap5-bench.scm"' \
	    '  (lambda (in) (test-expression (read in))))' \
	| ${SCHEME}

	${TIME} o/${HOSTTYPE}/chap10k

# Generate the C code corresponding to the running example of
# chapter 10.  The C code will be left in o/chap10kex.c
chap10k.example : src/c/chap10kex.c
src/c/chap10kex.c : src/chap10ex.scm src/chap10e.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(load "src/chap10k.scm")' \
	    '(load "src/chap10m.scm")' \
	    '(set! *cc+cflags* "${CC} ${CFLAGS}")' \
	    '(call-with-input-file' \
	    '  "src/chap10ex.scm"' \
	    '  (lambda (in) (test-expression (read in))))' \
	| ${SCHEME}

	size o/${HOSTTYPE}/chap10e
	emacs -batch -l el/c-indent.el
	mv o/chap10e.c src/c/chap10kex.c

# chap10j.scm contains an initialization analysis. It can be grafted
# to chap10e or chap10k without differences. As the others, it is
# very long.

# This test fails on continuations used out of their dynamic extent.
long.dynext.test.chap10je :
	if ${YOU_HAVE_TIME} ; then ${MAKE} dynext.test.chap10je ; else : ; fi
dynext.test.chap10je : test.chap10je
test.chap10je : src/chap10j.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(load "src/chap10j.scm")' \
	    '(and (test-scheme10e "src/scheme.tst")' \
	    '     (test-scheme10e "src/chap10e.tst")' \
	    '     (test-scheme10e "src/chap10j.tst"))' \
	| ${SCHEME}

# This one does not fail but lasts long...
long.test.chap10jk :
	if ${YOU_HAVE_TIME} ; then ${MAKE} test.chap10jk ; else : ; fi
test.chap10jk : src/chap10j.scm src/chap10p.scm
	echo \
	    '(load "src/chap10a.scm")' \
	    '(load "src/chap10c.scm")' \
	    '(load "src/chap10g.scm")' \
	    '(load "src/chap10e.scm")' \
	    '(load "src/chap10h.scm")' \
	    '(load "src/chap10f.scm")' \
	    '(load "src/chap10k.scm")' \
	    '(load "src/chap10m.scm")' \
	    '(load "src/chap10j.scm")' \
	    '(load "src/chap10p.scm")' \
	    '(and (test-scheme10k "src/scheme.tst")' \
	    '     (test-scheme10k "src/chap10e.tst")' \
	    '     (test-scheme10k "src/chap10k.tst")' \
	    '     (test-scheme10k "src/chap10j.tst"))' \
	| ${SCHEME}

# Compare time between o/$HOSTTYPE/c10ex.c and c10kex.c
# They have been modified from src/c/chap10[k]ex.c to repeat the
# computation 10000 times so their duration can be better estimated.
# Pay attention to the precise timing command.
compare.chap10 : o/${HOSTTYPE}/c10ex o/${HOSTTYPE}/c10kex
compare.chap10 :
	csh -c "time o/${HOSTTYPE}/c10ex"
	csh -c "time o/${HOSTTYPE}/c10kex"
bCFLAGS = -I../../src/c -ansi -pedantic -O
o/${HOSTTYPE}/c10ex : src/c/c10ex.c ${all-o}
	cd o/${HOSTTYPE} ; \
	${CC} ${bCFLAGS} -o c10ex ../../src/c/c10ex.c scheme.o schemelib.o

o/${HOSTTYPE}/c10kex : src/c/c10kex.c ${all-o}
	cd o/${HOSTTYPE} ; \
	${CC} ${bCFLAGS} -o c10kex ../../src/c/c10kex.c scheme.o schemeklib.o

######################################################### Common entries

# Build the necessary directories where will go specialized interpreters.
mkdir :
	-[ -d o ] || mkdir o
	-[ -d o/${HOSTTYPE} ] || mkdir o/${HOSTTYPE}

# Clean or recursively clean directories.
clean ::
	-rm -rf o/${HOSTTYPE}
	-rm chap10*.log

# Create tags for editing sources with Gnu Emacs.
tags : TAGS
TAGS :
	etags */?*.scm
