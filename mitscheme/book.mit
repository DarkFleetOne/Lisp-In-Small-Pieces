;;; $Id: book.elk,v 1.1 1996/01/29 19:44:09 queinnec Exp $

;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
;;; This file is part of the files that accompany the book:
;;;     LISP Implantation Semantique Programmation (InterEditions, France)
;;; By Christian Queinnec <Christian.Queinnec@INRIA.fr>
;;; Newest version may be retrieved from:
;;;   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
;;; Check the README file before using this file.
;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

;;; This file is used to customize Mit-Scheme in order to run the source
;;; files of the book. It preloads Meroonet, and the test-driver. It
;;; may serve as a basis for other ports to other Scheme
;;; interpreters. Look for the IMPORTANT notes below.

;;; This variable is used in chap8k.scm to determine the underlying
;;; Scheme interpreter.

(define book-interpreter-support 'mit)

;;; **IMPORTANT 1(but easy)**
;;; Missing functions:

(define gensym
  (let ((counter 99))
    (lambda args
      (set! counter (+ counter 1))
      (string->symbol
       (string-append
        (if (pair? args) (car args) "G")
        (number->string counter) ) ) ) ) )

(define call/cc call-with-current-continuation)

(define (atom? x) (not (pair? x)))

;;; I also like the iota function. (iota 0 4) -> (0 1 2 3)

(define (iota start end)
  (if (< start end)
      (cons start (iota (+ 1 start) end))
      '() ) )

(define (every? p . args)
  (let andmap ((args args) (value #t))
    (if (let any-at-end? ((ls args))
          (and (pair? ls)
               (or (not (pair? (car ls)))
                   (any-at-end? (cdr ls)))))
        value
        (let ((value (apply p (map car args))))
          (and value (andmap (map cdr args) value))))))

(define (any? p . args)
  (let ormap ((args args) (value #f))
    (if (let any-at-end? ((ls args))
          (and (pair? ls)
               (or (not (pair? (car ls)))
                   (any-at-end? (cdr ls)))))
        value
        (let ((value (apply p (map car args))))
          (or value (ormap (map cdr args) value))))))

(define (symbol-append . args)
  (string->symbol
   (apply string-append
          (map (lambda (s)
                 (cond ((string? s) s)
                       ((symbol? s) (symbol->string s))
                       ((number? s) (number->string s))
                       (else (error 'symbol-append args)) ) )
               args ) ) ) )


(load-option 'synchronous-subprocess)

(define (system command)
  (run-shell-command command))

(define (display-exception v)
  (let ((condition (and (pair? v) (car v))))
    (if (condition? condition)
      (write-condition-report condition stdout-port)
      (display v) ) ) )

;;; Name the Un*x ports and flush them.
;;; Seems that there is no stderr?

(define stdout-port (current-output-port))
(define stderr-port (current-output-port))

(define flush-buffer flush-output)

;;; Quick and dirty: sometimes very big objects are printed, limit
;;; them to something affordable.

(define *bounded-length* 4)
(define *bounded-depth* 3)

(define (bounded-display o stream)
  (define (print-list o* len dep)
    (cond ((null? o*) #t)
          ((atom? o*) (display " . " stream)
                      (display o* stream) )
          ((pair? o*) 
           (print (car o*) len (+ dep 1))
           (if (pair? (cdr o*)) (display " " stream))
           (print-list (cdr o*) (+ len 1) dep) ) ) )
  (define (print o len dep)
    (cond ((object? o) 
           (display "#<" stream)
           (display (Class-name (object->class o)) stream)
           (display ">" stream) )
          ((atom? o) (display o stream))
           (else (if (or (> len *bounded-length*)
                         (> dep *bounded-depth*) )
                     (display "&&&" stream)
                     (begin
                       (display "(" stream)
                       (print-list o len dep)
                       (display ")" stream) ) ) ) ) )
  (print o 0 0) )
;;; Test: (bounded-display (call-with-input-file "si/reflisp.scm" read) stdout-port)

;;; Sometimes property lists are seldom used.
;;; I did not find them quickly so I use a (slow) replacement.

(define putprop 'wait)
(define getprop 'wait)

(let ((properties '()))
  (set! putprop
        (lambda (symbol key value)
          (let ((plist (assq symbol properties)))
            (if (pair? plist)
                (let ((couple (assq key (cdr plist))))
                  (if (pair? couple)
                      (set-cdr! couple value)
                      (set-cdr! plist (cons (cons key value)
                                            (cdr plist) )) ) )
                (let ((plist (list symbol (cons key value))))
                  (set! properties (cons plist properties)) ) ) )
          value ) )
  (set! getprop
        (lambda (symbol key)
          (let ((plist (assq symbol properties)))
            (if (pair? plist)
                (let ((couple (assq key (cdr plist))))
                  (if (pair? couple)
                      (cdr couple)
                      #f ) )
                #f ) ) ) ) )

;;; pp is present (and autoloaded)

;;; Attention Mit-Scheme confuses #f and () as Scheme->C.

(define-syntax s2c-if
  (syntax-rules ()
      ((s2c-if condition . rest)
	(if (let ((c condition))
	       (or c (null? c)) )
	     . rest ) ) ) )


;;; Mit-scheme's eval requires a second argument, the environment. Redefine
;;; eval to make the second argument optional, so as not to break code that
;;; expects a one-arg eval.
(define native-eval eval)

(define (eval exp . env)
  (native-eval exp (if (null? env) user-initial-environment (car env))) ) 

;;; Calls to this function might be generated by syntax-case.scm

(define (list* . args)
  (if (pair? args)
      (if (pair? (cdr args))
          (cons (car args) (apply list* (cdr args)))
          (car args) )
      (quote ()) ) )

;;; Two macros that I frequently use:
(define-syntax unless
  (syntax-rules ()
    ((unless condition form ...)
     (if (not condition) (begin form ...)) ) ) )

(define-syntax when
  (syntax-rules ()
    ((when condition form ...)
     (if condition (begin form ...)) ) ) )

;;; This function loads a file expanded with syntax-expand.
;;;
;;; 2014 Note: This function is not needed anymore, since the built-in load can
;;; now do syntax-case expansion. Leaving this here for now since the verbose
;;; loading might prove useful for debugging.

(define *syntax-case-load-verbose?* #f)

(define (syntax-case-load file)
  (call-with-input-file file
    (lambda (in)
      (if *syntax-case-load-verbose?* 
          (begin (newline)
                 (display ";;; Loading ")
                 (display file)
                 (newline) ) )
      (let loop ((e (read in)))
        (if (eof-object? e) 
            file
            (let ((r (eval e user-initial-environment)))
              (if *syntax-case-load-verbose?*
                  (begin (display ";= ")
                         (display r)
                         (newline) ) )
              (loop (read in)) ) ) ) ) ) )

;;; Defines specific locations for error handlers for meroonet.scm and
;;; tester.scm. They will be filled later.

(define meroonet-error 'wait)

(define tester-error 'wait)

;;; pp is already present but not format. but format needs internal functions
;;; of pp so redefine pp.

(load "common/pp.scm")

(load "common/format.scm")

;;; Load the test-driver.

(load "src/tester.scm")

;;; Load Meroonet. Meroonet defines three macros with
;;; define-meroonet-macro. These macros are not needed by the rest of
;;; this file, so it is sufficient to register them with syntax-case.
;;; But, instead of syntax-case-loading the file, I only load it with 
;;; a definition of define-meroonet-macro that defines it for Dybvig.

(define-syntax define-macro
  (syntax-rules ()
    ((define-macro (name . args) body ...)
     (define-syntax name
       (rsc-macro-transformer
         (let ((transformer (lambda args body ...)))
           (lambda (exp env)
             (apply transformer (cdr exp))) ) ) ) ) ) )

(define-macro (define-meroonet-macro call . body)
  `(define-macro ,call . ,body) )

(load "meroonet/meroonet.scm")

;;; Since the define-abbreviation is also necessary for the book when
;;; non high level macros are defined, register define-abbreviation
;;; for syntax-case. 

(define-syntax define-abbreviation
   (syntax-rules ()
     ((define-abbreviation call . body)
      (define-meroonet-macro call . body) ) ) )

;;; **IMPORTANT 2**
;;; The test-driver should try to catch errors of the underlying Scheme 
;;; system. This is non-portable and difficult in many implementations. If
;;; do not succeed writing it, you can still run the programs of the book
;;; but you will not be able to run all the test-suites since some tests 
;;; (for instance in meroonet/oo-tests.scm) require errors to be caught
;;; when signalled by list-tail with a non-numeric second argument.

;(set! error-handler
;      (lambda error-msg
;        (error-print error-msg) ) )

;;; This function will test a suite of tests.

(define (test file)
  (suite-test
   file "?? " "== " #t
   (lambda (read check err)
     (define (the-error . args)
       (apply err args) )
     (set! meroonet-error the-error)
     (set! tester-error    the-error)
     (lambda ()
       (bind-condition-handler () the-error
           (lambda ()
             (let ((e (read)))
               (check (eval e user-initial-environment)) ) ) ) ) )
   equal? ) )
;;; Test: 
;;;	(test "meroonet/oo-tests.scm")
;;;	(test "src/syntax.tst")

(define (get-internal-run-time) 
  (real-time-clock) ) ; needed by (test "src/syntax.tst")

;;; This variable is needed by meroonet/oo-tests.scm test suite.

(define the-Point 'useful4tests)

;;; Generally, when an error is detected in one of my programs, a
;;; <something>-error function is called which calls itself wrong. The
;;; wrong function allows the test-driver to be aware that something
;;; went wrong.

(define wrong 'wait)
(define static-wrong 'wait)

;;; The `show' and `clone' generic functions are predefined in Meroon
;;; not in Meroonet.  The problem is to define a generic function with
;;; Meroonet macros while these macros are only compiled and not yet
;;; present.

;;; The clone function that performs a shallow copy of a Meroonet object.

(define-generic (show (o) . stream)
  (let ((stream (if (pair? stream) (car stream)
                    (current-output-port) )))
    (bounded-display o stream) ) )

(define-generic (clone (o))
  (list->vector (vector->list o)) )

;;; A small toplevel loop.
(define (start)
  (display "[C. Queinnec's book] Mit-Scheme+Meroonet+syntax-case...")
  (newline)
  (set! *syntax-case-load-verbose?* #t)
  (set! load syntax-case-load)
  (interpreter
   "? " "= " #t
   (lambda (read print err)
     (set! tester-error   err)
     (set! meroonet-error err)
     (lambda ()
       (bind-condition-handler () err
         (lambda ()
           (let ((e (read)))
             (print (eval e user-initial-environment)) ) ) ) ) ) )
  (display " Ite LiSP est.")
  (newline)
  (exit 0) )

;;; Warp into the new toplevel.
(start)

;;; end of book.mit
