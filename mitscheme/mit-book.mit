;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))
;;; This file is part of the files that accompany the book:
;;;     LISP Implantation Semantique Programmation (InterEditions, France)
;;; By Christian Queinnec <Christian.Queinnec@INRIA.fr>
;;; Newest version may be retrieved from:
;;;   (IP 128.93.2.54) ftp.inria.fr:INRIA/Projects/icsla/Books/LiSP*.tar.gz
;;; Check the README file before using this file.
;;;(((((((((((((((((((((((((((((((( L i S P ))))))))))))))))))))))))))))))))

;;; This file is used to customize Mit-Scheme in order to run the source
;;; files of the book. It preloads Meroonet, and the test-driver. It
;;; may serve as a basis for other ports to other Scheme
;;; interpreters. Look for the IMPORTANT notes below.

;;; This variable is used in chap8k.scm to determine the underlying
;;; Scheme interpreter.

(define book-interpreter-support 'mit)

(load-option 'synchronous-subprocess)

(define (system command)
  (run-shell-command command))

(define (display-exception v)
  (let ((condition (and (pair? v) (car v))))
    (if (condition? condition)
      (write-condition-report condition stdout-port)
      (display v) ) ) )

;;; Name the Un*x ports and flush them.
;;; Seems that there is no stderr?

(define current-error-port notification-output-port)                                          

(define flush-buffer flush-output)

(define (get-internal-run-time)
  (real-time-clock) ) ; needed by (test "src/syntax.tst")

;;; Attention Mit-Scheme confuses #f and () as Scheme->C.

(define-syntax s2c-if
  (syntax-rules ()
      ((s2c-if condition . rest)
	(if (let ((c condition))
	       (or c (null? c)) )
	     . rest ) ) ) )

;;; Mit-scheme's eval requires a second argument, the environment. Redefine
;;; eval to make the second argument optional, so as not to break code that
;;; expects a one-arg eval.
(define native-eval eval)

(define (eval exp . env)
  (native-eval exp (if (null? env) user-initial-environment (car env))) ) 

(define-syntax define-macro
  (syntax-rules ()
    ((define-macro (name . args) body ...)
     (define-syntax name
       (rsc-macro-transformer
         (let ((transformer (lambda args body ...)))
           (lambda (exp env)
             (apply transformer (cdr exp))) ) ) ) ) ) )


;;; end of book.mit
